(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{161:function(s,a,e){"use strict";e.r(a);var n=e(0),t=Object(n.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[s._v("#")]),s._v(" node")]),s._v(" "),e("h2",{attrs:{id:"node模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node模块"}},[s._v("#")]),s._v(" node模块")]),s._v(" "),e("h3",{attrs:{id:"path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path"}},[s._v("#")]),s._v(" path")]),s._v(" "),e("p",[s._v("这个模块想必大家应该都并不陌生，瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到.")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const path = require('path');\n\nlet str = '/root/a/b/index.html';\nconsole.log(path.dirname(str)); // 路径\n// /root/a/b\nconsole.log(path.extname(str)); // 后缀名\n// .html\nconsole.log(path.basename(str)); // 文件名\n// index.html\n\n// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径\nlet pathOne = path.resolve('rooot/a/b', '../c', 'd', '..', 'e');\n\n// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录\nlet pathTwo = path.resolve(__dirname, 'build'); // 这个用法很常见，你应该在 webpack 中有见过\n\nconsole.log(pathOne, pathTwo, __dirname);\n// pathOne  =>  /Users/lgq/Desktop/node/rooot/a/c/e\n// pathTwo  =>  /Users/lgq/Desktop/node/build\n// __dirname  =>  /Users/lgq/Desktop/node\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br")])]),e("h3",{attrs:{id:"assert-断言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#assert-断言"}},[s._v("#")]),s._v(" assert 断言")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// assert.js\nconst assert = require('assert');\n\nconst obj1 = { a: { b: 1 } };\nconst obj2 = { a: { b: 1 } };\nconst obj3 = { a: { b: '1' } };\n\n// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值\n// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值\n// 同样也是错误的时候抛出信息，正确的时候继续默默执行\nassert.deepEqual(obj1, obj2, '不等哦'); // true\nassert.deepEqual(obj1, obj3, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj2, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj3, '不等哦'); // false，这个会抛出错误信息\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("h3",{attrs:{id:"stream-流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stream-流"}},[s._v("#")]),s._v(" stream 流")]),s._v(" "),e("p",[s._v("stream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 fs.readFile 和 fs.writeFile 的升级版。\n我们要知道 readFile 和 writeFile 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const fs = require('fs');\n\n// 读取流：fs.createReadStream();\n// 写入流：fs.createWriteStream();\nlet rs = fs.createReadStream('a.txt'); // 要读取的文件\nlet ws = fs.createWriteStream('a2.txt'); // 输出的文件\n\nrs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br")])]),e("p",[s._v("另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。\n##node框架")])])}),[],!1,null,null,null);a.default=t.exports}}]);